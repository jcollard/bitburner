// Recursively deploy a script to all root access neighbors
// The script will run with the name of that server as an argument

var splitArgs = args[0].split(',');
var deployScript = splitArgs[0];
var scriptName = getScriptName();

function checked(neighbor) {
	if (neighbor.startsWith("purchased_server")) return true;
	for (var ix = 1; ix < splitArgs.length; ix++) {
		if (splitArgs[ix] === neighbor) return true;
	}
	return false;
}

function addArgs(neighbors) {
	var n = args[0];
	for (var ix = 0; ix < neighbors.length; ix++) {
		var neighbor = neighbors[ix];
		n += "," + neighbor;
	}
	return n;
}

function recurse(neighbor) {
	scp(scriptName, neighbor);
	// Do not hack machines that cannot run this script
	if (getServerMaxRam(neighbor) < getScriptRam(scriptName)) return;

	// Stop everything on server and hack neighbors
	killall(neighbor);
	var pid = exec(scriptName, neighbor, 1, newArgs);

	// Wait for recursive deploy to finish
	while (true) {
		var s = getRunningScript(pid, neighbor);
		if (s == null) break;
		sleep(1000);
	}
}

function deploy(neighbor) {
	scp(deployScript, neighbor);
	if (getServerMaxRam(neighbor) < getScriptRam(deployScript)) return;
	var scriptRam = getScriptRam(deployScript, neighbor);
	var serverRam = getServerMaxRam(neighbor);
	var maxThreads = Math.floor(serverRam / scriptRam);
	killall(neighbor);
	exec(deployScript, neighbor, maxThreads, neighbor);
}

var newArgs = "";

function main() {
	var neighbors = scan();
	newArgs = addArgs(neighbors);
	for (var ix = 0; ix < neighbors.length; ix++) {
		var neighbor = neighbors[ix];
		if (neighbor === "home" || checked(neighbor)) continue;

		// Ignore machines where we do not have root access
		if (!hasRootAccess(neighbor))  continue;
		// And recurse to neighbors
		recurse(neighbor);
		// Then deploy script
		deploy(neighbor);
	}
}

main();